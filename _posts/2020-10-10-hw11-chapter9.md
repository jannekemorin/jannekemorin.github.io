---
layout: posts
title:  "HW11: Chapter 9"
---
#### 9.8 Briefly describe the three main types of software maintenance. Why is it sometimes difficult to distinguish between them?
**Fault repairs to fix bugs and vulnerabilities:** This type of maintenance involves correcting coding, design, or requirements errors. Coding errors are the cheapest to fix, followed by design errors, which may invovle rewriting several program components. The mostly costly of all is requirements errors, which may involve extensive system redesign.

**Environmental adaptation to adapt the software to new platforms and environments:** This type of software maintenance involves modifying application systems to cope with changes to some aspect of the environment such as the databse or the platform operating system.

**Functionality addition to add new features and to support new requirements:** This type of software maintenace involves adapting the software to changes to system requirements resulting from changes to organizational or business change. This is often the most time and effort-intensive type of maintenance.

One of the reasons it becomes difficult to distinguish between these types of maintenance is the overlap between them - they often occur concurrently. For example, you could run into and proceed to fix faults in the software as you are adapting it to new requirements and features. Likewise, fixing a feature may result in adding a whole new one to accomodate the necessary changes. Additionally, these types of maintenance have alternative names that can cause confusion such as "corrective", "adaptive", and "perfective".


#### 9.10 Do software engineers have professional responsibility to develop code that can be easily maintained even if their employer does not explicitly request it?

They certainly do. Developing code that can be easily maintained is best software engineering practice as most all code needs to be maintained regularly, especially that of a dynamic company. It's only in the software engineers' best interest, anyway. If they plan to work somewhere long-term, developing difficult-to-maintain code will shoot *themselves* in the foot when a fault surfaces or a new feature needs to be added down the line. When they run into this situation, they will not be working efficiently as a software engineer and, one could argue, not doing their job well. It's in their best interest and a common courtesy to fellow developers who may need to maintain the code. 
